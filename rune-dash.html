<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rune Dash</title>
  <style>
    html, body { height: 100%; margin: 0; background: #050607; overflow: hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud {
      position: fixed; left: 12px; top: 12px; color: rgba(235,245,255,.92);
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select: none;
      text-shadow: 0 1px 10px rgba(0,0,0,.8);
    }
    .hud b { font-size: 16px; }
    .hint { opacity:.75; margin-top:6px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" id="hud"></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const hud = document.getElementById("hud");

  // --- Resize handling
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // --- Themes (press T to cycle)
  const themes = [
    { name: "Void Neon", bg: "#050607", player: "#9ff", rune: "#7f7", danger: "#ff6b6b", ui: "rgba(235,245,255,.92)" },
    { name: "Arcane Violet", bg: "#07050a", player: "#d7b5ff", rune: "#9ad5ff", danger: "#ff7bd4", ui: "rgba(245,235,255,.92)" },
    { name: "Amber Relic", bg: "#070605", player: "#ffd9a8", rune: "#ffe27a", danger: "#ff6a3d", ui: "rgba(255,245,235,.92)" },
    { name: "Frost", bg: "#05070a", player: "#b7e7ff", rune: "#c8ffd8", danger: "#ff7c7c", ui: "rgba(235,250,255,.92)" },
  ];
  let themeIdx = 0;
  const theme = () => themes[themeIdx];

  // --- Input
  const keys = new Set();
  addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "t") { themeIdx = (themeIdx + 1) % themes.length; return; }
    if (k === "r") { if (!state.running) reset(); return; }
    keys.add(k);
    // prevent scroll on arrows/space
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
  }, { passive: false });

  addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()), { passive: true });

  // --- Utility
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const hypot = Math.hypot;

  // --- Game state
  const state = {
    running: true,
    time: 0,
    score: 0,
    best: 0,
    difficulty: 1,
    spawnTimer: 0,
    runeTimer: 0,
    shake: 0
  };

  const player = {
    x: innerWidth/2, y: innerHeight/2,
    r: 10,
    speed: 260,
    invuln: 0
  };

  const enemies = [];
  const runes = [];
  const particles = [];

  function reset() {
    state.running = true;
    state.time = 0;
    state.score = 0;
    state.difficulty = 1;
    state.spawnTimer = 0;
    state.runeTimer = 0;
    state.shake = 0;
    enemies.length = 0;
    runes.length = 0;
    particles.length = 0;
    player.x = innerWidth/2; player.y = innerHeight/2;
    player.invuln = 0;
  }

  // spawn from edges, heading inward-ish
  function spawnEnemy() {
    const side = Math.floor(Math.random()*4);
    let x,y;
    if (side===0){ x = rand(0, innerWidth); y = -20; }
    if (side===1){ x = innerWidth+20; y = rand(0, innerHeight); }
    if (side===2){ x = rand(0, innerWidth); y = innerHeight+20; }
    if (side===3){ x = -20; y = rand(0, innerHeight); }

    const angle = Math.atan2(player.y - y, player.x - x) + rand(-0.6, 0.6);
    const speed = rand(80, 120) + state.difficulty * rand(12, 20);
    enemies.push({
      x, y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      r: rand(10, 16),
      spin: rand(-3, 3),
      a: rand(0, Math.PI*2)
    });
  }

  function spawnRune() {
    const x = rand(40, innerWidth-40);
    const y = rand(40, innerHeight-40);
    runes.push({ x, y, r: 8, t: 0 });
  }

  function burst(x,y,color,amount=14) {
    for (let i=0;i<amount;i++){
      const a = rand(0, Math.PI*2);
      const s = rand(60, 240);
      particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: rand(0.35, 0.7), t: 0, color });
    }
  }

  function gameOver() {
    state.running = false;
    state.best = Math.max(state.best, Math.floor(state.score));
    state.shake = 0.18;
    burst(player.x, player.y, theme().danger, 28);
  }

  // --- Main loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // Clear
    ctx.fillStyle = theme().bg;
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // Screen shake
    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt);
    const shakeAmt = state.shake * 10;
    const sx = (Math.random()*2-1) * shakeAmt;
    const sy = (Math.random()*2-1) * shakeAmt;
    ctx.save();
    ctx.translate(sx, sy);

    // Update timers
    state.time += dt;
    if (state.running) {
      state.score += dt * 10;
      state.difficulty = 1 + state.time * 0.08;
    }

    // Spawning
    if (state.running) {
      state.spawnTimer -= dt;
      const spawnEvery = clamp(0.9 - state.difficulty*0.03, 0.22, 0.9);
      if (state.spawnTimer <= 0) {
        state.spawnTimer = spawnEvery;
        spawnEnemy();
      }

      state.runeTimer -= dt;
      if (state.runeTimer <= 0) {
        state.runeTimer = rand(2.5, 4.2);
        spawnRune();
      }
    }

    // Player movement
    const ax = (keys.has("a")||keys.has("arrowleft") ? -1 : 0) + (keys.has("d")||keys.has("arrowright") ? 1 : 0);
    const ay = (keys.has("w")||keys.has("arrowup") ? -1 : 0) + (keys.has("s")||keys.has("arrowdown") ? 1 : 0);
    const len = Math.hypot(ax, ay) || 1;

    if (state.running) {
      player.x += (ax/len) * player.speed * dt;
      player.y += (ay/len) * player.speed * dt;
      player.x = clamp(player.x, player.r+4, innerWidth - player.r-4);
      player.y = clamp(player.y, player.r+4, innerHeight - player.r-4);
      player.invuln = Math.max(0, player.invuln - dt);
    }

    // Update enemies
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if (state.running) {
        // slight homing as difficulty rises
        const toA = Math.atan2(player.y - e.y, player.x - e.x);
        const curA = Math.atan2(e.vy, e.vx);
        const turn = clamp((toA - curA + Math.PI*3)%(Math.PI*2)-Math.PI, -1, 1);
        const turnRate = 0.6 + state.difficulty*0.05;
        const a = curA + turn*turnRate*dt;
        const sp = Math.hypot(e.vx, e.vy);
        e.vx = Math.cos(a)*sp;
        e.vy = Math.sin(a)*sp;
      }

      e.x += e.vx * dt;
      e.y += e.vy * dt;
      e.a += e.spin * dt;

      // collision with player
      const d = hypot(player.x - e.x, player.y - e.y);
      if (state.running && player.invuln <= 0 && d < player.r + e.r) {
        gameOver();
      }

      // cleanup if far off screen
      if (e.x < -200 || e.x > innerWidth+200 || e.y < -200 || e.y > innerHeight+200) {
        enemies.splice(i,1);
      }
    }

    // Update runes (collect)
    for (let i=runes.length-1;i>=0;i--){
      const r = runes[i];
      r.t += dt;
      const d = hypot(player.x - r.x, player.y - r.y);
      if (state.running && d < player.r + r.r + 2) {
        runes.splice(i,1);
        state.score += 25;
        player.invuln = 0.25; // tiny grace
        state.shake = Math.min(0.12, state.shake + 0.04);
        burst(r.x, r.y, theme().rune, 18);
      }
    }

    // Update particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.pow(0.02, dt); // quick damp
      p.vy *= Math.pow(0.02, dt);
      if (p.t >= p.life) particles.splice(i,1);
    }

    // Draw runes
    for (const r of runes){
      const pulse = 1 + Math.sin(r.t*6)*0.12;
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.scale(pulse, pulse);
      ctx.beginPath();
      ctx.arc(0,0,r.r,0,Math.PI*2);
      ctx.fillStyle = theme().rune;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme().rune;
      ctx.stroke();
      ctx.restore();
    }

    // Draw enemies (spiky orbs)
    for (const e of enemies){
      const spikes = 10;
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(e.a);
      ctx.beginPath();
      for (let i=0;i<spikes;i++){
        const a = (i/spikes)*Math.PI*2;
        const rr = e.r * (i%2===0 ? 1.18 : 0.82);
        ctx.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
      }
      ctx.closePath();
      ctx.fillStyle = theme().danger;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      ctx.restore();
    }

    // Draw particles
    for (const p of particles){
      const k = 1 - (p.t/p.life);
      ctx.globalAlpha = k;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x-2, p.y-2, 4, 4);
    }
    ctx.globalAlpha = 1;

    // Draw player (rogue-ish: circle + little dagger notch)
    ctx.save();
    ctx.translate(player.x, player.y);
    const blink = player.invuln > 0 ? (Math.sin(now*0.04) > 0 ? 0.35 : 1) : 1;
    ctx.globalAlpha = blink;

    // body
    ctx.beginPath();
    ctx.arc(0,0,player.r,0,Math.PI*2);
    ctx.fillStyle = theme().player;
    ctx.fill();

    // dagger mark
    ctx.beginPath();
    ctx.moveTo(player.r*0.2, -player.r*0.2);
    ctx.lineTo(player.r*1.35, 0);
    ctx.lineTo(player.r*0.2, player.r*0.2);
    ctx.closePath();
    ctx.globalAlpha = 0.75 * blink;
    ctx.fillStyle = theme().player;
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;

    ctx.restore(); // unshake

    // HUD
    hud.style.color = theme().ui;
    const s = Math.floor(state.score);
    const b = Math.max(state.best, s);
    hud.innerHTML = `
      <b>Rune Dash</b><br/>
      Score: <b>${s}</b> &nbsp; Best: <b>${b}</b><br/>
      Theme: <b>${theme().name}</b>
      <div class="hint">Move: WASD / Arrows &nbsp; | &nbsp; T: Theme &nbsp; | &nbsp; R: Restart</div>
      ${state.running ? "" : `<div class="hint"><b>Game Over.</b> Press <b>R</b>.</div>`}
    `;

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
